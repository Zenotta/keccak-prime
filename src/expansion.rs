//! Implements the expansion function.

use crate::constants::{BLOCK_HEADER_SIZE, INPUT_HASH_SIZE, NONCE_SIZE};
use crate::prng::{self, PrngState};

use num_bigint::BigUint;

use std::convert::TryInto;

const USAGE_NUMBER: u8 = 0xff;

/// Takes a previous hash, root merkle hash and nonce as an input.
/// Outputs a value in the domain of the VDF permutation function.
pub fn expand(
    prev_hash: [u8; INPUT_HASH_SIZE],
    root_hash: [u8; INPUT_HASH_SIZE],
    nonce: [u8; NONCE_SIZE],
    penalty: u16,
    delay: u16,
    loop_count: u16,
    max: BigUint,
) -> BigUint {
    // integer X chosen uniformly at random from the set of integers {0, 1, ... max}.
    let mut prng = PrngState::new(
        &derive_key(prev_hash, root_hash, nonce, penalty, delay, loop_count),
        USAGE_NUMBER,
    );

    loop {
        let mut byte_array = prng.get_bytes(168); // 1344 bits = SHAKE-128 bit rate

        byte_array.extend_from_slice(&root_hash);

        let x = BigUint::from_bytes_be(&byte_array);

        if x <= max {
            return x;
        }
    }
}

/// Derives a key for the PRNG.
fn derive_key(
    prev_hash: [u8; INPUT_HASH_SIZE],
    root_hash: [u8; INPUT_HASH_SIZE],
    nonce: [u8; NONCE_SIZE],
    penalty: u16,
    delay: u16,
    loop_count: u16,
) -> [u8; BLOCK_HEADER_SIZE] {
    let mut key = Vec::with_capacity(prng::KEY_LEN);

    key.extend_from_slice(&prev_hash);
    key.extend_from_slice(&root_hash);
    key.extend_from_slice(&delay.to_be_bytes());
    key.extend_from_slice(&loop_count.to_be_bytes());
    key.extend_from_slice(&penalty.to_be_bytes());
    key.extend_from_slice(&nonce);

    key[0..BLOCK_HEADER_SIZE].try_into().unwrap()
}

#[cfg(test)]
mod tests {
    use crate::constants::MAX;

    use super::*;

    #[test]
    fn expansion_test_vectors() {
        let prev_hash = [
            0xa8, 0xe5, 0x1b, 0x87, 0xd9, 0x57, 0x87, 0xe8, 0xa8, 0x2a, 0x6d, 0xf0, 0xd8, 0x1c,
            0x6e, 0x16, 0xd6, 0xe5, 0x8b, 0x9e, 0x91, 0x18, 0x9b, 0x7a, 0xa7, 0xd7, 0x0a, 0x03,
            0xfe, 0xb8, 0x35, 0xc8,
        ];

        let root_hash = [
            0x60, 0xfb, 0xd3, 0x63, 0x48, 0x27, 0x35, 0x48, 0x76, 0x92, 0x20, 0x3b, 0xbc, 0xce,
            0x71, 0x0d, 0xb3, 0xdb, 0x72, 0x94, 0x3e, 0x0b, 0x82, 0xad, 0x26, 0x2a, 0xbc, 0x00,
            0x5a, 0x35, 0x7c, 0x23,
        ];

        let nonce = [0x39, 0x74, 0xb6, 0x7b, 0xd7, 0x1a, 0xab, 0xba, 0x8e, 0x42];

        let res = expand(
            prev_hash,
            root_hash,
            nonce,
            0x7498,
            0xf4dc,
            0xf59a,
            MAX.clone(),
        );

        let expected_res = BigUint::from_bytes_be(&[
            0x3f, 0x9f, 0xf0, 0x08, 0xce, 0x77, 0x37, 0x3d, 0x76, 0x92, 0x21, 0xb9, 0x33, 0xe2,
            0x73, 0x26, 0xc5, 0xa6, 0x40, 0x0c, 0xe5, 0xf8, 0x9e, 0x38, 0x18, 0x5e, 0x7d, 0xc4,
            0x68, 0xd1, 0xf3, 0xa9, 0xc0, 0x39, 0xb0, 0x2b, 0x30, 0x79, 0x7e, 0x9d, 0x41, 0x37,
            0x68, 0x8d, 0x2e, 0x16, 0xe4, 0x8e, 0x38, 0x66, 0x40, 0xcd, 0x90, 0x97, 0xeb, 0x78,
            0x40, 0x61, 0xda, 0x0a, 0x3f, 0xe8, 0x9c, 0x25, 0xba, 0x58, 0x98, 0x67, 0xad, 0x42,
            0x6a, 0xfb, 0x74, 0x75, 0x1e, 0x4f, 0xbc, 0x4a, 0x83, 0x71, 0xfe, 0xc0, 0x59, 0x50,
            0x6f, 0xce, 0x4e, 0x52, 0xa8, 0xf3, 0x24, 0x97, 0xf9, 0x98, 0x58, 0x30, 0xb7, 0x70,
            0xd0, 0x39, 0xff, 0xc9, 0x73, 0x87, 0xc4, 0x69, 0x24, 0xfb, 0x2c, 0x02, 0xe6, 0x78,
            0x77, 0xe0, 0x2a, 0x44, 0xdb, 0xf2, 0x33, 0x38, 0x8f, 0xeb, 0x07, 0xab, 0x00, 0x70,
            0xd8, 0x0e, 0x66, 0x75, 0xe3, 0xf2, 0x89, 0xe6, 0x25, 0x3c, 0x30, 0xba, 0x0e, 0xb2,
            0xe4, 0x34, 0x5c, 0x05, 0x89, 0xcc, 0xf8, 0x96, 0xb0, 0x7b, 0x6f, 0xa0, 0xbb, 0x11,
            0x27, 0xc0, 0xe1, 0x9d, 0xa0, 0x50, 0x13, 0xc9, 0xbb, 0x26, 0x9c, 0xf4, 0x39, 0x20,
            0x60, 0xfb, 0xd3, 0x63, 0x48, 0x27, 0x35, 0x48, 0x76, 0x92, 0x20, 0x3b, 0xbc, 0xce,
            0x71, 0x0d, 0xb3, 0xdb, 0x72, 0x94, 0x3e, 0x0b, 0x82, 0xad, 0x26, 0x2a, 0xbc, 0x00,
            0x5a, 0x35, 0x7c, 0x23,
        ]);

        assert_eq!(res, expected_res);
    }

    // Verify that the output has an expected size.
    #[test]
    fn verify_output_size() {
        // prime ùëû = 21600 ‚àí 2273;
        // integer max = ùëû ‚àí 1.

        let prev_hash = [1u8; INPUT_HASH_SIZE];
        let root_hash = [2u8; INPUT_HASH_SIZE];
        let nonce = [3u8; NONCE_SIZE];

        let res = expand(prev_hash, root_hash, nonce, 0, 0, 0, MAX.clone());

        assert!(res <= *MAX);
    }
}
