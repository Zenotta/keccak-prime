//! Sloth VDF implementation.
//!
//! Implementation follows the Section 3 in paper "A random zoo" [1].
//! We use a single round of Keccak-f[1600] as a permutation function.
//!
//! [1] https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session1-wesolowski-paper.pdf

// TODO: implement this module using crypto_bigint once it's more stable.

// use crypto_bigint::{nlimbs, MulMod, UInt};
use std::{convert::TryInto, iter};

use crate::constants::{SEED, SEED_EXPONENT, SEED_SIGNED};
use num_bigint::{BigInt, BigUint};
use num_traits::{One, Zero};

use crate::{inverse::inverse_keccak_function, keccakf::RC, WORDS};

// Define a single-round Keccak-f and its inverse - we use it as permutation function.
inverse_keccak_function!("`inverse-keccak-f[1600, 1]`", inverse_keccakf_1, 1, RC);
keccak_function!("`keccak-f[1600, 1]`", keccakf_1, 1, RC);

/// Defines internal integer type.
/// This should be at least `2 ^ (2*k)`, where `k` is the security level.
type Int = BigUint;

/// Implements the Rho function as seen in Section 3.2 of the paper.
fn rho(x: Int) -> Int {
    let x1 = x.modpow(&SEED_EXPONENT, &SEED);

    let x2 = (&x * &x1) % &*SEED; // = x ^ ((p + 1) / 4)
    let is_even = &x2 % Int::from(2u8) == Int::zero();

    let x3 = (&x1 * &x2) % &*SEED; // = x ^ ((p - 1) / 2)

    // Check for quadratic residue
    let quad_res = x3 <= Int::one();

    if is_even == quad_res {
        x2
    } else {
        (&*SEED - &x2) % &*SEED
    }
}

/// Inverse Rho function.
fn rho_inverse(x: Int) -> Int {
    let x = BigInt::from(x);
    let is_even = &x % 2 == BigInt::zero();

    let multiplier = BigInt::from(if is_even { 1 } else { -1 });

    ((&multiplier * &x * &x % &*SEED_SIGNED + &*SEED_SIGNED) % &*SEED_SIGNED)
        .to_biguint()
        // unwrap is fine here because `mod SEED_SIGNED` guarantees it's a positive number
        .unwrap()
}

/// Permutation function. It is implemented using a single round of Keccak.
fn sigma(x: Int) -> Int {
    let mut bytes = (&x % &*SEED).to_u64_digits();

    // Ensure the `bytes` length is exactly `keccak_prime::WORDS` bytes.
    // FIXME: account for endianness
    if bytes.len() < WORDS {
        bytes.splice(0..0, iter::repeat(0).take(WORDS - bytes.len()));
    } else if bytes.len() > WORDS {
        bytes.resize(WORDS, 0);
    }

    // Convert Int into a bit string suitable for Keccak-f which is `[u64; WORDS]`.
    let mut byte_array: [u64; WORDS] = bytes
        .try_into()
        .expect("unexpected incorrect input for keccak-f");

    // Apply a single round of Keccak-f.
    inverse_keccakf_1(&mut byte_array);

    let bytes = &byte_array
        .iter()
        .flat_map(|v| v.to_le_bytes())
        .collect::<Vec<_>>();

    Int::from_bytes_le(&bytes)
}

/// Inverse of a permutation function. In our case, it's simply a
/// single round of inverse Keccak-f[1600].
fn sigma_inverse(x: Int) -> Int {
    let mut bytes = x.to_u64_digits();

    // Ensure the `bytes` length is exactly `keccak_prime::WORDS` bytes.
    bytes.resize(WORDS, 0);

    // Convert Int into a bit string suitable for Keccak-f which is `[u64; WORDS]`.
    let mut byte_array = bytes
        .try_into()
        .expect("unexpected incorrect input for keccak-f");

    // Apply inverse Keccak-f.
    keccakf_1(&mut byte_array);

    // Convert a bit string into an integer.
    // num_bigint expects the input to be `Vec<u32>`.
    // FIXME: get rid of unsafety
    Int::new(unsafe {
        let (_prefix, digits_u32, _suffix) = byte_array.align_to::<u32>();
        digits_u32.to_owned()
    })
}

/// Implements the Tau function as seen in Section 3.2 of the paper.
/// It composes the Rho function with the permutation function Sigma -
/// which in our case is a single round of Keccak.
fn tau(x: Int) -> Int {
    sigma(rho(x))
}

/// Implements the inverse Tau function.
fn tau_inverse(x: Int) -> Int {
    rho_inverse(sigma_inverse(x))
}

/// ## Arguments
/// - `s` is the security parameter.
/// - `delay` is the desired puzzle difficulty.
///
/// ## Returns
/// - Witness number.
pub fn solve(s: Int, delay: u16) -> Int {
    let mut w_iter = s;

    for _ in 0..delay {
        w_iter = tau(w_iter);
    }

    w_iter
}

/// ## Arguments
/// - `s` is the security parameter.
/// - `w` is the witness number obtained from `solve`.
/// - `delay` is the puzzle difficulty.
///
/// ## Returns
/// - `true` if the verification has passed.
pub fn verify(s: Int, w: Int, delay: u16) -> bool {
    let mut w_iter = w;

    for _ in 0..delay {
        w_iter = tau_inverse(w_iter);
    }

    w_iter == s
}

#[cfg(test)]
mod tests {
    use super::{rho, rho_inverse, sigma, solve, verify};
    use crate::constants::Int;
    use num_bigint::BigUint;
    use std::time::Instant;

    #[test]
    fn sloth() {
        let x = BigUint::from(11u64);
        let t = 100;

        // compute the sloth vdf
        let instant = Instant::now();
        let witness = solve(x.clone(), t);
        println!("{}, eval: {} ms", witness, instant.elapsed().as_millis());

        // verify the result
        let instant = Instant::now();
        assert!(verify(x, witness.clone(), t));
        println!("verified in {} ms", instant.elapsed().as_millis());
    }

    /// Testing on test vectors taken from the specification.
    #[test]
    fn rho_test_vectors() {
        {
            assert_eq!(rho(Int::from(0u8)), Int::from(0u8));
        }
        {
            let expected = Int::parse_bytes(b"fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff71e", 16).unwrap();
            assert_eq!(rho(Int::from(1u8)), expected);
        }
        {
            let x = Int::parse_bytes(b"f12ceb98ae50c59570860a5159dc58d10c8eb4acc3e4dc5c949ab47f4727aeccd9374b3830f563227daa0c340bdd89c70b13055d16bb5a9d1823b30265243ace332fdd45107443ca68542b9ec02207416a590d0e3e829af15227853ada56d2abdcfcb4efd96aba69025aa5f26936330755d9dbc1dc43ca84d77381c0e48c560d757aa4e8245cf10ff428ed2897127c094f45c7ef626ce4e08a9043844b4bfe141419607701ed7b6769a3a4a7f0038263add45c49bcd1771b6bf3db4331ee96c755c70a6550710fa5", 16).unwrap();
            let expected = Int::parse_bytes(b"85bf38f105494aba1032d60c0cd5b14f48686e76582a0f22b60079fe3a380b8e3092dbfdfb994739d6dba5f3ee2f8b0bd923521392758c0a9bbb47ec4f990300e37144b3874997fdc1c7a0a10a0eeb05138fc970b52157a5f7266799766ea9226b2487a4763f482658d6a298299a9716f8e77918cd01ca6a1c0ef72030c4cfbf7a679a2fc96e690683b2d85bd86dbe2129c3f2145dd4284639fab32957452ebdf46bd9d1317bde07c55fbfb9627d161ae4c34c2f6606802c743b4aabb812942a0962135d288aa9e3", 16).unwrap();
            assert_eq!(rho(Int::from(x)), expected);
        }
        {
            let x = Int::parse_bytes(b"4928b0f415b721f6478a60deccb79421686eb572241ceab570eb683624f198c616fdd42298ec0d80b736e511873e4dceb6b2abd0a11e351022e6e43b242aeb024b65064b5ce01b914118ab43f1b2945cc4e9236708a8654171c04a2e0ca0183d0978a69c5020255928c0394e608ddd691198ac1138495d6320b6d62878a65297fdcfe62036ec1d18a3c78b0ca8d4593a701060933efb4b6b05c0764b9f404a7ce883e129697da9bfa65cef86fbe02b3f6943624a79aedc7554f74c41f349974fa464f078d9e53b86", 16).unwrap();
            let expected = Int::parse_bytes(b"197033a7ca4c1dcf00d82830deaa6d040040cd02705634394b24966726e49f45d155048aadadb211b26f5a3b942a6a67f90b4996df59215bf19ddec59a27ad6043814279e67a39e1fe2d99b9fa557278dd3416a7a403057d108864ee33c8f315364798c53e2005f6ea435d1454253469af1017d8cec09defe8b58ff16090061e406f524eb26fd9479b115b5d4f4e2ab40b1550db4e976f01b04b25f273f804936615b032d1d40366901baac498939baed10bc130298145b02631fce6c5aa2b8364b6d8bc6388c1e1", 16).unwrap();
            assert_eq!(rho(Int::from(x)), expected);
        }
    }

    #[test]
    fn vdf_test_vectors() {
        let v = Int::parse_bytes(b"0cefc8a2d6aa028bb1e3405d3c8ba9426c932dfe2b805b5ef3d1f83d662933efb019b55347c0627231c4e67305b53caf4aedb98c3feee7c4fb942bf482afd256bfd7592195dba6c38339c44042179a00b3d45fa57a4d248149d06322cfd1f6112bbc3532b72fbc764352b697e807b42ca520d7e07f94f5213abe9b588e4ede403dfc13bd0f4e6e43f2bde4ed9d131477dca904266f5e6fb39ff276cad65f4cfa460f08481d75dc39405da37be0fed3538231c878d6ea14f68a18268c3ccf9f4ad26ed8f6a2806efe", 16).unwrap();
        let witness = solve(v, 2);
        assert_eq!(witness, Int::from(1u8));
    }

    /// Testing on example values taken from the specification.
    #[test]
    fn sigma_test_vectors() {
        {
            let expected = Int::from_bytes_le(&[
                0xc4, 0x6b, 0x6a, 0xe2, 0x35, 0xd5, 0xc4, 0xeb, 0x35, 0xf1, 0xe2, 0x9a, 0x78, 0xe1,
                0x35, 0x71, 0x78, 0x4d, 0x44, 0xbc, 0x26, 0x9a, 0x78, 0xcd, 0x26, 0x5e, 0x5b, 0x13,
                0xaf, 0xb5, 0x26, 0xde, 0xaf, 0x89, 0x8f, 0xd7, 0xc4, 0x17, 0xaf, 0x09, 0xc5, 0x6b,
                0x6a, 0xe2, 0x35, 0xd5, 0xc4, 0xeb, 0x35, 0xf1, 0xf2, 0x9a, 0x78, 0xe1, 0x35, 0x71,
                0x78, 0x4d, 0x44, 0xbc, 0x26, 0x9a, 0x78, 0xcd, 0x26, 0x5e, 0x5b, 0x13, 0xaf, 0xb5,
                0x26, 0xde, 0xaf, 0x89, 0x8f, 0xd7, 0xc4, 0x17, 0xaf, 0x09, 0xc5, 0x6b, 0x6a, 0xe2,
                0x35, 0xd5, 0xc4, 0xeb, 0x35, 0xf1, 0xe2, 0x9a, 0x78, 0xe1, 0x35, 0x71, 0x78, 0x4d,
                0x44, 0xbc, 0x26, 0x9a, 0x78, 0xcd, 0x26, 0x5e, 0x5b, 0x13, 0xaf, 0xb5, 0x26, 0xde,
                0xaf, 0x89, 0x8f, 0xd7, 0xc4, 0x17, 0xaf, 0x09, 0xc5, 0x6b, 0x6a, 0xe2, 0x35, 0xd5,
                0xc4, 0xeb, 0x35, 0xf1, 0xe2, 0x9a, 0x78, 0xe1, 0x35, 0x71, 0x78, 0x4d, 0x44, 0xbc,
                0x26, 0x9a, 0x78, 0xcd, 0x26, 0x5e, 0x5b, 0x13, 0xaf, 0xbd, 0x26, 0xde, 0xaf, 0x89,
                0x8f, 0xd7, 0xc4, 0x17, 0xaf, 0x09, 0xc5, 0x6b, 0x6a, 0xe2, 0x35, 0xd5, 0xc4, 0xeb,
                0x35, 0xf1, 0xe2, 0x9a, 0x78, 0xe1, 0x35, 0x71, 0x78, 0x4d, 0x44, 0xbc, 0x26, 0x9a,
                0x78, 0xcd, 0x26, 0x5e, 0x5b, 0x13, 0xaf, 0xb5, 0x26, 0xde, 0xaf, 0x89, 0x8f, 0xd7,
                0xc4, 0x17, 0xaf, 0x09,
            ]);
            assert_eq!(sigma(Int::from(0u8)), expected);

            let value = Int::from_bytes_le(&[
                0x35, 0xb9, 0x4e, 0xfd, 0x11, 0x62, 0xe8, 0x61, 0x3c, 0x3b, 0x19, 0x2d, 0x23, 0x4e,
                0xb3, 0x1b, 0x5d, 0x32, 0xca, 0xe5, 0x11, 0x1c, 0xac, 0xd4, 0xa9, 0x43, 0xf1, 0xa4,
                0x5a, 0xb7, 0xe1, 0x37, 0xb0, 0x3f, 0x9d, 0xd5, 0x62, 0x34, 0x32, 0x4e, 0xae, 0xb6,
                0xd3, 0x42, 0x4b, 0x18, 0xfa, 0xf5, 0x1b, 0xd6, 0x70, 0xcb, 0x3a, 0x80, 0xa3, 0x59,
                0x40, 0xa1, 0xbc, 0x03, 0x03, 0x65, 0x50, 0x6c, 0x67, 0xac, 0x3e, 0x74, 0xec, 0x96,
                0x4b, 0x71, 0x02, 0xa2, 0xfe, 0x08, 0xd0, 0xd2, 0xe5, 0x5f, 0x99, 0x80, 0x86, 0x45,
                0x2d, 0x7e, 0x16, 0xac, 0xf2, 0x4a, 0x86, 0x1c, 0x40, 0x27, 0xb9, 0xf9, 0xa9, 0x8a,
                0x59, 0x7e, 0x51, 0xac, 0x8e, 0x8f, 0x94, 0xec, 0x4b, 0x75, 0x74, 0xf4, 0x36, 0x28,
                0xe0, 0x4a, 0xcb, 0x96, 0xaa, 0x0a, 0x24, 0xb0, 0xce, 0x8a, 0xd8, 0x8e, 0x22, 0x9d,
                0x8a, 0x55, 0xcb, 0x56, 0xe4, 0xce, 0x64, 0x0c, 0x85, 0xdf, 0x71, 0x1b, 0x47, 0x9a,
                0x6d, 0x2f, 0xc2, 0x44, 0x20, 0xdf, 0x6e, 0x38, 0xa3, 0xdd, 0xec, 0xc0, 0xba, 0x20,
                0x25, 0xc6, 0x40, 0x6e, 0x24, 0xea, 0x15, 0xf9, 0xca, 0x48, 0x59, 0xda, 0x86, 0x0a,
                0x45, 0x68, 0x6c, 0xac, 0x2a, 0xb4, 0x73, 0x64, 0x34, 0xc1, 0x68, 0x7f, 0x0d, 0x3b,
                0x55, 0xfc, 0x6b, 0xea, 0x27, 0x1f, 0x4a, 0xa1, 0x8f, 0x09, 0xac, 0xdb, 0x8c, 0xad,
                0x3f, 0x0e, 0xa4, 0x43,
            ]);
            let expected = Int::from_bytes_le(&[
                0x48, 0xd9, 0x0d, 0xf7, 0xe3, 0x31, 0x5e, 0xa7, 0xda, 0x74, 0x58, 0x6d, 0xc2, 0x8a,
                0x28, 0x52, 0xf9, 0x64, 0xf3, 0x61, 0x8d, 0xd1, 0x46, 0x41, 0x8c, 0xf4, 0x95, 0x11,
                0x46, 0xb3, 0xe8, 0x95, 0x85, 0x8c, 0x37, 0x7f, 0xa2, 0xd7, 0x25, 0x2f, 0xf3, 0x70,
                0x6f, 0x6e, 0xce, 0x02, 0x5f, 0x0c, 0xb8, 0x6f, 0x76, 0x96, 0x16, 0xa7, 0xb2, 0xf1,
                0xd4, 0xc2, 0xa8, 0x8c, 0x34, 0xd8, 0x2b, 0xd8, 0xe3, 0x3e, 0xb2, 0xb9, 0xf3, 0x9c,
                0xf9, 0x4f, 0x01, 0xe6, 0x89, 0xe7, 0xe6, 0xa6, 0x98, 0xc8, 0x57, 0xf8, 0xca, 0xea,
                0x42, 0xc7, 0xe4, 0x4f, 0x1c, 0xe5, 0xf0, 0x65, 0x5a, 0xc5, 0xb9, 0xfd, 0xed, 0x57,
                0x68, 0xc5, 0x68, 0x24, 0x7b, 0x81, 0xd2, 0xcd, 0xa5, 0x68, 0x0c, 0x98, 0xd4, 0xd4,
                0x94, 0x03, 0x90, 0xa7, 0xcd, 0x6b, 0x8e, 0xc4, 0x85, 0xa2, 0xc9, 0xaf, 0x07, 0xf1,
                0xbc, 0x47, 0x9f, 0x7e, 0xe8, 0xf3, 0x64, 0x44, 0x11, 0xd8, 0x07, 0x83, 0xca, 0x97,
                0xe1, 0x16, 0x84, 0xbb, 0x4f, 0xfc, 0xdc, 0x44, 0x1a, 0xa9, 0x0e, 0x36, 0x1a, 0x56,
                0x70, 0xa6, 0x6c, 0x8c, 0x53, 0x70, 0x8f, 0xc7, 0x7f, 0xd8, 0x89, 0xfb, 0x9b, 0x9b,
                0xfb, 0x82, 0xdc, 0xfd, 0x1e, 0xbf, 0x97, 0x8e, 0xfd, 0x92, 0x2d, 0xa2, 0x8c, 0x3e,
                0x63, 0xbc, 0xc8, 0x9b, 0x46, 0x4a, 0x0d, 0x49, 0x3f, 0xbd, 0x03, 0x5f, 0x0f, 0x22,
                0xee, 0xf2, 0x90, 0x00,
            ]);
            assert_eq!(sigma(value), expected);

            let expected = Int::from_bytes_le(&[
                0x26, 0x5e, 0xc4, 0x6b, 0xe2, 0x11, 0x8f, 0x81, 0xaf, 0x89, 0x26, 0xf1, 0x9a, 0xd4,
                0x24, 0x80, 0xc4, 0x6b, 0x71, 0x4d, 0xbc, 0xe2, 0xd5, 0x80, 0x35, 0xf1, 0x23, 0x5e,
                0x13, 0x93, 0x58, 0x82, 0x78, 0x4d, 0xab, 0x89, 0xd7, 0xb8, 0x46, 0x81, 0x27, 0x5e,
                0xc4, 0x6b, 0xe2, 0x11, 0x8f, 0x81, 0xaf, 0x89, 0x36, 0xf1, 0x9a, 0xd4, 0x24, 0x80,
                0xc4, 0x6b, 0x71, 0x4d, 0xbc, 0xe2, 0xd5, 0x84, 0x35, 0xf1, 0x23, 0x5e, 0x13, 0x93,
                0x58, 0x82, 0x78, 0x4d, 0xab, 0x89, 0xd7, 0xb8, 0x46, 0x81, 0x27, 0x5e, 0xc4, 0x6b,
                0xe2, 0x11, 0x8f, 0x81, 0xaf, 0x89, 0x26, 0xf1, 0x9a, 0xd4, 0x24, 0x80, 0xc4, 0x6b,
                0x71, 0x4d, 0xbc, 0xe2, 0xd5, 0x84, 0x35, 0xf1, 0x23, 0x5e, 0x13, 0x93, 0x58, 0x82,
                0x78, 0x4d, 0xa9, 0x89, 0xd7, 0xb8, 0x46, 0x81, 0x27, 0x5e, 0xc4, 0x6b, 0xe2, 0x11,
                0x8f, 0x81, 0xaf, 0x89, 0x26, 0xf1, 0x9a, 0xd4, 0x24, 0x80, 0xc4, 0x6b, 0x71, 0x4d,
                0xbc, 0xe2, 0xd5, 0x84, 0x35, 0xf1, 0x23, 0x5e, 0x13, 0x9b, 0x58, 0x82, 0x78, 0x4d,
                0xab, 0x89, 0xd7, 0xb8, 0x46, 0x81, 0x27, 0x5e, 0xc4, 0x6b, 0xe2, 0x11, 0x8f, 0x81,
                0xaf, 0x89, 0x26, 0xf1, 0x9a, 0xd4, 0x64, 0x80, 0xc4, 0x6b, 0x71, 0x4d, 0xbc, 0xe2,
                0xd5, 0x84, 0x35, 0xf1, 0x23, 0x5e, 0x13, 0x93, 0x58, 0x82, 0x78, 0x4d, 0xab, 0x89,
                0xd7, 0xb8, 0x46, 0x81,
            ]);
            assert_eq!(sigma(Int::from(1u8)), expected);
        }
    }
}
