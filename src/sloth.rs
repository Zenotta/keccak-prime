//! Sloth VDF implementation.
//!
//! Implementation follows the Section 3 in paper "A random zoo" [1].
//! We use a single round of Keccak-f[1600] as a permutation function.
//!
//! [1] https://csrc.nist.gov/csrc/media/events/workshop-on-elliptic-curve-cryptography-standards/documents/papers/session1-wesolowski-paper.pdf

// TODO: implement this module using crypto_bigint once it's more stable.

// use crypto_bigint::{nlimbs, MulMod, UInt};
use crate::{
    constants::{SEED, SEED_EXPONENT, SEED_SIGNED},
    Buffer,
};
use num_bigint::{BigInt, BigUint};
use num_traits::{One, Zero};

use crate::{inverse::inverse_keccak_function, keccakf::RC, WORDS};

// Define a single-round Keccak-f and its inverse - we use it as permutation function.
inverse_keccak_function!("`inverse-keccak-f[1600, 1]`", inverse_keccakf_1, 1, RC);
keccak_function!("`keccak-f[1600, 1]`", keccakf_1, 1, RC);

/// Defines internal integer type.
/// This should be at least `2 ^ (2*k)`, where `k` is the security level.
type Int = BigUint;

/// Implements the Rho function as seen in Section 3.2 of the paper.
fn rho(x: Int) -> Int {
    let x1 = x.modpow(&SEED_EXPONENT, &SEED);

    let x2 = (&x * &x1) % &*SEED; // = x ^ ((p + 1) / 4)
    let is_even = &x2 % Int::from(2u8) == Int::zero();

    let x3 = (&x1 * &x2) % &*SEED; // = x ^ ((p - 1) / 2)

    // Check for quadratic residue
    let quad_res = x3 <= Int::one();

    if is_even == quad_res {
        x2
    } else {
        (&*SEED - &x2) % &*SEED
    }
}

/// Inverse Rho function.
fn rho_inverse(x: Int) -> Int {
    let x = BigInt::from(x);
    let is_even = &x % 2 == BigInt::zero();

    let multiplier = BigInt::from(if is_even { 1 } else { -1 });

    ((&multiplier * &x * &x % &*SEED_SIGNED + &*SEED_SIGNED) % &*SEED_SIGNED)
        .to_biguint()
        // unwrap is fine here because `mod SEED_SIGNED` guarantees it's a positive number
        .unwrap()
}

/// Generic permutation function Sigma.
/// It takes a type argument which is a Keccak function that needs to be applied
/// to the input bytes. This is used to quickly implement the inverse function.
fn sigma_generic<KeccakF: FnMut(&mut [u64; WORDS])>(mut keccak_fn: KeccakF, x: Int) -> Int {
    let bytes = (&x % &*SEED).to_bytes_be();

    // Ensure the `bytes` length is exactly `keccak_prime::WORDS` bytes.
    let mut keccak_state = Buffer([0; WORDS]);
    keccak_state.xorin(&bytes, (WORDS * 8) - bytes.len(), bytes.len());

    // Apply a single round of Keccak-f.
    loop {
        keccak_fn(keccak_state.words());

        let mut out = [0u8; WORDS * 8];
        keccak_state.setout(&mut out, 0, WORDS * 8);

        let res = Int::from_bytes_be(&out);

        if &res < &*SEED {
            return res;
        }
    }
}

/// Sigma implemented using a single round of Keccak.
fn sigma(x: Int) -> Int {
    sigma_generic(inverse_keccakf_1, x)
}

/// Inverse of a permutation function. In our case, it's simply a
/// single round of inverse Keccak-f[1600].
fn sigma_inverse(x: Int) -> Int {
    sigma_generic(keccakf_1, x)
}

/// ## Arguments
/// - `s` is the security parameter.
/// - `delay` is the desired puzzle difficulty.
///
/// ## Returns
/// - Witness number.
pub fn solve(s: Int, delay: u16) -> Int {
    let mut w_iter = s;

    if delay > 0 {
        w_iter = rho(w_iter);

        for _ in 1..delay {
            w_iter = sigma(w_iter);
            w_iter = rho(w_iter);
        }
    }

    w_iter
}

/// ## Arguments
/// - `s` is the security parameter.
/// - `w` is the witness number obtained from `solve`.
/// - `delay` is the puzzle difficulty.
///
/// ## Returns
/// - `true` if the verification has passed.
pub fn verify(s: Int, w: Int, delay: u16) -> bool {
    let mut w_iter = w;

    if delay > 0 {
        w_iter = rho_inverse(w_iter);

        for _ in 1..delay {
            w_iter = sigma_inverse(w_iter);
            w_iter = rho_inverse(w_iter);
        }
    }

    w_iter == s
}

#[cfg(test)]
mod tests {
    use super::{rho, rho_inverse, sigma, solve, verify};
    use crate::constants::Int;
    use num_bigint::BigUint;
    use std::time::Instant;

    #[test]
    fn sloth() {
        let x = BigUint::from(11u64);
        let t = 100;

        // compute the sloth vdf
        let instant = Instant::now();
        let witness = solve(x.clone(), t);
        println!("{}, eval: {} ms", witness, instant.elapsed().as_millis());

        // verify the result
        let instant = Instant::now();
        assert!(verify(x, witness.clone(), t));
        println!("verified in {} ms", instant.elapsed().as_millis());
    }

    /// Testing on test vectors taken from the specification.
    #[test]
    fn rho_test_vectors() {
        {
            assert_eq!(rho(Int::from(0u8)), Int::from(0u8));
        }
        {
            let expected = Int::from_bytes_be(&[
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xf7, 0x1e,
            ]);
            assert_eq!(rho(Int::from(1u8)), expected);
        }
        {
            let x = Int::from_bytes_be(&[
                0xf1, 0x2c, 0xeb, 0x98, 0xae, 0x50, 0xc5, 0x95, 0x70, 0x86, 0x0a, 0x51, 0x59, 0xdc,
                0x58, 0xd1, 0x0c, 0x8e, 0xb4, 0xac, 0xc3, 0xe4, 0xdc, 0x5c, 0x94, 0x9a, 0xb4, 0x7f,
                0x47, 0x27, 0xae, 0xcc, 0xd9, 0x37, 0x4b, 0x38, 0x30, 0xf5, 0x63, 0x22, 0x7d, 0xaa,
                0x0c, 0x34, 0x0b, 0xdd, 0x89, 0xc7, 0x0b, 0x13, 0x05, 0x5d, 0x16, 0xbb, 0x5a, 0x9d,
                0x18, 0x23, 0xb3, 0x02, 0x65, 0x24, 0x3a, 0xce, 0x33, 0x2f, 0xdd, 0x45, 0x10, 0x74,
                0x43, 0xca, 0x68, 0x54, 0x2b, 0x9e, 0xc0, 0x22, 0x07, 0x41, 0x6a, 0x59, 0x0d, 0x0e,
                0x3e, 0x82, 0x9a, 0xf1, 0x52, 0x27, 0x85, 0x3a, 0xda, 0x56, 0xd2, 0xab, 0xdc, 0xfc,
                0xb4, 0xef, 0xd9, 0x6a, 0xba, 0x69, 0x02, 0x5a, 0xa5, 0xf2, 0x69, 0x36, 0x33, 0x07,
                0x55, 0xd9, 0xdb, 0xc1, 0xdc, 0x43, 0xca, 0x84, 0xd7, 0x73, 0x81, 0xc0, 0xe4, 0x8c,
                0x56, 0x0d, 0x75, 0x7a, 0xa4, 0xe8, 0x24, 0x5c, 0xf1, 0x0f, 0xf4, 0x28, 0xed, 0x28,
                0x97, 0x12, 0x7c, 0x09, 0x4f, 0x45, 0xc7, 0xef, 0x62, 0x6c, 0xe4, 0xe0, 0x8a, 0x90,
                0x43, 0x84, 0x4b, 0x4b, 0xfe, 0x14, 0x14, 0x19, 0x60, 0x77, 0x01, 0xed, 0x7b, 0x67,
                0x69, 0xa3, 0xa4, 0xa7, 0xf0, 0x03, 0x82, 0x63, 0xad, 0xd4, 0x5c, 0x49, 0xbc, 0xd1,
                0x77, 0x1b, 0x6b, 0xf3, 0xdb, 0x43, 0x31, 0xee, 0x96, 0xc7, 0x55, 0xc7, 0x0a, 0x65,
                0x50, 0x71, 0x0f, 0xa5,
            ]);
            let expected = Int::from_bytes_be(&[
                0x85, 0xbf, 0x38, 0xf1, 0x05, 0x49, 0x4a, 0xba, 0x10, 0x32, 0xd6, 0x0c, 0x0c, 0xd5,
                0xb1, 0x4f, 0x48, 0x68, 0x6e, 0x76, 0x58, 0x2a, 0x0f, 0x22, 0xb6, 0x00, 0x79, 0xfe,
                0x3a, 0x38, 0x0b, 0x8e, 0x30, 0x92, 0xdb, 0xfd, 0xfb, 0x99, 0x47, 0x39, 0xd6, 0xdb,
                0xa5, 0xf3, 0xee, 0x2f, 0x8b, 0x0b, 0xd9, 0x23, 0x52, 0x13, 0x92, 0x75, 0x8c, 0x0a,
                0x9b, 0xbb, 0x47, 0xec, 0x4f, 0x99, 0x03, 0x00, 0xe3, 0x71, 0x44, 0xb3, 0x87, 0x49,
                0x97, 0xfd, 0xc1, 0xc7, 0xa0, 0xa1, 0x0a, 0x0e, 0xeb, 0x05, 0x13, 0x8f, 0xc9, 0x70,
                0xb5, 0x21, 0x57, 0xa5, 0xf7, 0x26, 0x67, 0x99, 0x76, 0x6e, 0xa9, 0x22, 0x6b, 0x24,
                0x87, 0xa4, 0x76, 0x3f, 0x48, 0x26, 0x58, 0xd6, 0xa2, 0x98, 0x29, 0x9a, 0x97, 0x16,
                0xf8, 0xe7, 0x79, 0x18, 0xcd, 0x01, 0xca, 0x6a, 0x1c, 0x0e, 0xf7, 0x20, 0x30, 0xc4,
                0xcf, 0xbf, 0x7a, 0x67, 0x9a, 0x2f, 0xc9, 0x6e, 0x69, 0x06, 0x83, 0xb2, 0xd8, 0x5b,
                0xd8, 0x6d, 0xbe, 0x21, 0x29, 0xc3, 0xf2, 0x14, 0x5d, 0xd4, 0x28, 0x46, 0x39, 0xfa,
                0xb3, 0x29, 0x57, 0x45, 0x2e, 0xbd, 0xf4, 0x6b, 0xd9, 0xd1, 0x31, 0x7b, 0xde, 0x07,
                0xc5, 0x5f, 0xbf, 0xb9, 0x62, 0x7d, 0x16, 0x1a, 0xe4, 0xc3, 0x4c, 0x2f, 0x66, 0x06,
                0x80, 0x2c, 0x74, 0x3b, 0x4a, 0xab, 0xb8, 0x12, 0x94, 0x2a, 0x09, 0x62, 0x13, 0x5d,
                0x28, 0x8a, 0xa9, 0xe3,
            ]);
            let res = rho(x.clone());
            assert_eq!(res, expected);
            assert_eq!(rho_inverse(res), x);
        }
        {
            let x = Int::from_bytes_be(&[
                0x49, 0x28, 0xb0, 0xf4, 0x15, 0xb7, 0x21, 0xf6, 0x47, 0x8a, 0x60, 0xde, 0xcc, 0xb7,
                0x94, 0x21, 0x68, 0x6e, 0xb5, 0x72, 0x24, 0x1c, 0xea, 0xb5, 0x70, 0xeb, 0x68, 0x36,
                0x24, 0xf1, 0x98, 0xc6, 0x16, 0xfd, 0xd4, 0x22, 0x98, 0xec, 0x0d, 0x80, 0xb7, 0x36,
                0xe5, 0x11, 0x87, 0x3e, 0x4d, 0xce, 0xb6, 0xb2, 0xab, 0xd0, 0xa1, 0x1e, 0x35, 0x10,
                0x22, 0xe6, 0xe4, 0x3b, 0x24, 0x2a, 0xeb, 0x02, 0x4b, 0x65, 0x06, 0x4b, 0x5c, 0xe0,
                0x1b, 0x91, 0x41, 0x18, 0xab, 0x43, 0xf1, 0xb2, 0x94, 0x5c, 0xc4, 0xe9, 0x23, 0x67,
                0x08, 0xa8, 0x65, 0x41, 0x71, 0xc0, 0x4a, 0x2e, 0x0c, 0xa0, 0x18, 0x3d, 0x09, 0x78,
                0xa6, 0x9c, 0x50, 0x20, 0x25, 0x59, 0x28, 0xc0, 0x39, 0x4e, 0x60, 0x8d, 0xdd, 0x69,
                0x11, 0x98, 0xac, 0x11, 0x38, 0x49, 0x5d, 0x63, 0x20, 0xb6, 0xd6, 0x28, 0x78, 0xa6,
                0x52, 0x97, 0xfd, 0xcf, 0xe6, 0x20, 0x36, 0xec, 0x1d, 0x18, 0xa3, 0xc7, 0x8b, 0x0c,
                0xa8, 0xd4, 0x59, 0x3a, 0x70, 0x10, 0x60, 0x93, 0x3e, 0xfb, 0x4b, 0x6b, 0x05, 0xc0,
                0x76, 0x4b, 0x9f, 0x40, 0x4a, 0x7c, 0xe8, 0x83, 0xe1, 0x29, 0x69, 0x7d, 0xa9, 0xbf,
                0xa6, 0x5c, 0xef, 0x86, 0xfb, 0xe0, 0x2b, 0x3f, 0x69, 0x43, 0x62, 0x4a, 0x79, 0xae,
                0xdc, 0x75, 0x54, 0xf7, 0x4c, 0x41, 0xf3, 0x49, 0x97, 0x4f, 0xa4, 0x64, 0xf0, 0x78,
                0xd9, 0xe5, 0x3b, 0x86,
            ]);
            let expected = Int::from_bytes_be(&[
                0x19, 0x70, 0x33, 0xa7, 0xca, 0x4c, 0x1d, 0xcf, 0x00, 0xd8, 0x28, 0x30, 0xde, 0xaa,
                0x6d, 0x04, 0x00, 0x40, 0xcd, 0x02, 0x70, 0x56, 0x34, 0x39, 0x4b, 0x24, 0x96, 0x67,
                0x26, 0xe4, 0x9f, 0x45, 0xd1, 0x55, 0x04, 0x8a, 0xad, 0xad, 0xb2, 0x11, 0xb2, 0x6f,
                0x5a, 0x3b, 0x94, 0x2a, 0x6a, 0x67, 0xf9, 0x0b, 0x49, 0x96, 0xdf, 0x59, 0x21, 0x5b,
                0xf1, 0x9d, 0xde, 0xc5, 0x9a, 0x27, 0xad, 0x60, 0x43, 0x81, 0x42, 0x79, 0xe6, 0x7a,
                0x39, 0xe1, 0xfe, 0x2d, 0x99, 0xb9, 0xfa, 0x55, 0x72, 0x78, 0xdd, 0x34, 0x16, 0xa7,
                0xa4, 0x03, 0x05, 0x7d, 0x10, 0x88, 0x64, 0xee, 0x33, 0xc8, 0xf3, 0x15, 0x36, 0x47,
                0x98, 0xc5, 0x3e, 0x20, 0x05, 0xf6, 0xea, 0x43, 0x5d, 0x14, 0x54, 0x25, 0x34, 0x69,
                0xaf, 0x10, 0x17, 0xd8, 0xce, 0xc0, 0x9d, 0xef, 0xe8, 0xb5, 0x8f, 0xf1, 0x60, 0x90,
                0x06, 0x1e, 0x40, 0x6f, 0x52, 0x4e, 0xb2, 0x6f, 0xd9, 0x47, 0x9b, 0x11, 0x5b, 0x5d,
                0x4f, 0x4e, 0x2a, 0xb4, 0x0b, 0x15, 0x50, 0xdb, 0x4e, 0x97, 0x6f, 0x01, 0xb0, 0x4b,
                0x25, 0xf2, 0x73, 0xf8, 0x04, 0x93, 0x66, 0x15, 0xb0, 0x32, 0xd1, 0xd4, 0x03, 0x66,
                0x90, 0x1b, 0xaa, 0xc4, 0x98, 0x93, 0x9b, 0xae, 0xd1, 0x0b, 0xc1, 0x30, 0x29, 0x81,
                0x45, 0xb0, 0x26, 0x31, 0xfc, 0xe6, 0xc5, 0xaa, 0x2b, 0x83, 0x64, 0xb6, 0xd8, 0xbc,
                0x63, 0x88, 0xc1, 0xe1,
            ]);
            assert_eq!(rho(x), expected);
        }
    }

    #[test]
    fn vdf_test_vectors() {
        {
            let v = Int::from_bytes_be(&[
                0x0c, 0xef, 0xc8, 0xa2, 0xd6, 0xaa, 0x02, 0x8b, 0xb1, 0xe3, 0x40, 0x5d, 0x3c, 0x8b,
                0xa9, 0x42, 0x6c, 0x93, 0x2d, 0xfe, 0x2b, 0x80, 0x5b, 0x5e, 0xf3, 0xd1, 0xf8, 0x3d,
                0x66, 0x29, 0x33, 0xef, 0xb0, 0x19, 0xb5, 0x53, 0x47, 0xc0, 0x62, 0x72, 0x31, 0xc4,
                0xe6, 0x73, 0x05, 0xb5, 0x3c, 0xaf, 0x4a, 0xed, 0xb9, 0x8c, 0x3f, 0xee, 0xe7, 0xc4,
                0xfb, 0x94, 0x2b, 0xf4, 0x82, 0xaf, 0xd2, 0x56, 0xbf, 0xd7, 0x59, 0x21, 0x95, 0xdb,
                0xa6, 0xc3, 0x83, 0x39, 0xc4, 0x40, 0x42, 0x17, 0x9a, 0x00, 0xb3, 0xd4, 0x5f, 0xa5,
                0x7a, 0x4d, 0x24, 0x81, 0x49, 0xd0, 0x63, 0x22, 0xcf, 0xd1, 0xf6, 0x11, 0x2b, 0xbc,
                0x35, 0x32, 0xb7, 0x2f, 0xbc, 0x76, 0x43, 0x52, 0xb6, 0x97, 0xe8, 0x07, 0xb4, 0x2c,
                0xa5, 0x20, 0xd7, 0xe0, 0x7f, 0x94, 0xf5, 0x21, 0x3a, 0xbe, 0x9b, 0x58, 0x8e, 0x4e,
                0xde, 0x40, 0x3d, 0xfc, 0x13, 0xbd, 0x0f, 0x4e, 0x6e, 0x43, 0xf2, 0xbd, 0xe4, 0xed,
                0x9d, 0x13, 0x14, 0x77, 0xdc, 0xa9, 0x04, 0x26, 0x6f, 0x5e, 0x6f, 0xb3, 0x9f, 0xf2,
                0x76, 0xca, 0xd6, 0x5f, 0x4c, 0xfa, 0x46, 0x0f, 0x08, 0x48, 0x1d, 0x75, 0xdc, 0x39,
                0x40, 0x5d, 0xa3, 0x7b, 0xe0, 0xfe, 0xd3, 0x53, 0x82, 0x31, 0xc8, 0x78, 0xd6, 0xea,
                0x14, 0xf6, 0x8a, 0x18, 0x26, 0x8c, 0x3c, 0xcf, 0x9f, 0x4a, 0xd2, 0x6e, 0xd8, 0xf6,
                0xa2, 0x80, 0x6e, 0xfe,
            ]);
            let witness = solve(v, 2);
            assert_eq!(witness, Int::from(1u8));
        }
        {
            let v = Int::from_bytes_be(&[
                0xa1, 0xe4, 0x7c, 0xbb, 0xab, 0x0d, 0x9d, 0x6c, 0x1c, 0x26, 0x7e, 0x86, 0x4c, 0x19,
                0x58, 0x5b, 0x39, 0x47, 0xee, 0x6b, 0xd3, 0xcb, 0x40, 0xae, 0xe1, 0x2e, 0x9c, 0x9a,
                0x9d, 0x20, 0x63, 0x5d, 0xf0, 0x0c, 0xc1, 0x0b, 0x8a, 0x3f, 0x6b, 0xd0, 0x49, 0x54,
                0x7a, 0x0b, 0x57, 0xbd, 0x53, 0xa5, 0x52, 0xae, 0x68, 0x6c, 0x60, 0x22, 0xb6, 0xfd,
                0x34, 0xb2, 0x85, 0xde, 0x28, 0x48, 0xe8, 0x13, 0xb5, 0xad, 0xd6, 0xa7, 0x3b, 0x63,
                0x13, 0xe0, 0x31, 0x20, 0xac, 0x74, 0x43, 0xd5, 0xcb, 0x80, 0x57, 0x13, 0x46, 0xeb,
                0x77, 0xf6, 0xe3, 0x8b, 0xf3, 0x87, 0xac, 0x48, 0x78, 0x5c, 0x38, 0x17, 0x8c, 0x04,
                0x9e, 0xbe, 0xa0, 0x99, 0xb5, 0x27, 0x8a, 0x64, 0xfa, 0x03, 0x7c, 0xd6, 0x09, 0x2d,
                0xd5, 0x54, 0x7b, 0xaa, 0x59, 0xf7, 0x78, 0x55, 0x6c, 0x02, 0xb1, 0xa4, 0x07, 0x1d,
                0x1b, 0xa5, 0x36, 0xb2, 0xd2, 0xef, 0x40, 0x89, 0x11, 0xf8, 0x25, 0x62, 0x76, 0x76,
                0xbf, 0x98, 0xb9, 0xe3, 0xd6, 0x5e, 0xf5, 0x5f, 0x02, 0x1f, 0x18, 0x37, 0x10, 0x62,
                0xbd, 0xc6, 0x8d, 0x32, 0xaa, 0x31, 0xb1, 0x16, 0x67, 0x9d, 0x49, 0xcb, 0x57, 0xec,
                0x9c, 0x47, 0x4d, 0xa4, 0x7e, 0x80, 0xd1, 0x49, 0x70, 0x41, 0x2b, 0x01, 0x73, 0x75,
                0x68, 0x0e, 0x8a, 0x64, 0xa3, 0xe3, 0x88, 0x67, 0xfc, 0x73, 0xc7, 0x9a, 0xeb, 0x18,
                0x53, 0x91, 0x34, 0x99,
            ]);
            let expected = Int::from_bytes_be(&[
                0x80, 0x81, 0x3f, 0x5b, 0x23, 0xdc, 0x90, 0x69, 0xf1, 0xa3, 0x19, 0xb3, 0x46, 0x99,
                0xb4, 0x86, 0xfa, 0xa7, 0xc9, 0x54, 0xfc, 0x5b, 0x09, 0x0b, 0xf9, 0x0b, 0x97, 0x9a,
                0x67, 0xee, 0x6b, 0xd9, 0x0f, 0x20, 0x56, 0x93, 0x41, 0x09, 0x76, 0xc7, 0x46, 0xee,
                0xf8, 0xc8, 0x84, 0xf6, 0x4c, 0x82, 0xfe, 0x5e, 0x5a, 0xa7, 0x18, 0x3f, 0x6e, 0x0a,
                0xad, 0x89, 0x60, 0x28, 0x3f, 0x79, 0x67, 0xf2, 0xef, 0xa2, 0x28, 0x89, 0xfa, 0x94,
                0x9e, 0x0d, 0x51, 0xb1, 0xe7, 0x42, 0x55, 0x76, 0x0a, 0xbd, 0x2b, 0xa0, 0xdd, 0xf4,
                0x79, 0x56, 0xc3, 0x07, 0x61, 0xba, 0x7e, 0x1a, 0x86, 0x2f, 0xdd, 0x58, 0x1e, 0xa3,
                0xe3, 0xbe, 0x2f, 0xd3, 0xcf, 0x37, 0x64, 0x37, 0xf2, 0x7c, 0x71, 0xae, 0xc6, 0x0f,
                0x00, 0x55, 0x4f, 0x5e, 0x9b, 0xef, 0x3f, 0x1b, 0x1b, 0x73, 0x99, 0x67, 0x15, 0x5c,
                0xbf, 0xb3, 0x24, 0x92, 0xf4, 0xc1, 0xff, 0xf6, 0x68, 0xcd, 0xc6, 0x4e, 0x37, 0x04,
                0xc0, 0x9c, 0xd4, 0x31, 0x5a, 0x4b, 0xe7, 0xba, 0xff, 0x34, 0x77, 0x14, 0xf0, 0xfa,
                0x91, 0x29, 0xb5, 0x58, 0x3f, 0x28, 0x92, 0x7e, 0x32, 0xbc, 0x3d, 0x23, 0x71, 0x42,
                0x5d, 0x82, 0x12, 0x6e, 0x09, 0x52, 0x33, 0x1c, 0x72, 0xe1, 0xef, 0x54, 0x79, 0x7e,
                0x6c, 0x9c, 0x5b, 0xb3, 0xbc, 0x57, 0x5c, 0xa2, 0x14, 0xd6, 0x72, 0x46, 0x87, 0x56,
                0x1f, 0xba, 0x2d, 0x12,
            ]);
            let witness = solve(v, 2);
            assert_eq!(witness, expected);
        }
    }

    /// Testing on example values taken from the specification.
    #[test]
    fn sigma_test_vectors() {
        {
            {
                let expected = Int::parse_bytes(b"c46b6ae235d5c4eb35f1e29a78e13571784d44bc269a78cd265e5b13afb526deaf898fd7c417af09c56b6ae235d5c4eb35f1f29a78e13571784d44bc269a78cd265e5b13afb526deaf898fd7c417af09c56b6ae235d5c4eb35f1e29a78e13571784d44bc269a78cd265e5b13afb526deaf898fd7c417af09c56b6ae235d5c4eb35f1e29a78e13571784d44bc269a78cd265e5b13afbd26deaf898fd7c417af09c56b6ae235d5c4eb35f1e29a78e13571784d44bc269a78cd265e5b13afb526deaf898fd7c417af09", 16).unwrap();
                let res = sigma(Int::from(0u8));
                assert_eq!(res, expected);
            }
            {
                let expected = Int::parse_bytes(b"265ec46be2118f81af8926f19ad42480c46b714dbce2d58035f1235e13935882784dab89d7b84681275ec46be2118f81af8936f19ad42480c46b714dbce2d58435f1235e13935882784dab89d7b84681275ec46be2118f81af8926f19ad42480c46b714dbce2d58435f1235e13935882784da989d7b84681275ec46be2118f81af8926f19ad42480c46b714dbce2d58435f1235e139b5882784dab89d7b84681275ec46be2118f81af8926f19ad46480c46b714dbce2d58435f1235e13935882784dab89d7b84681", 16).unwrap();
                let res = sigma(Int::from(1u8));
                assert_eq!(res, expected);
            }
            {
                let value = Int::parse_bytes(b"35b94efd1162e8613c3b192d234eb31b5d32cae5111cacd4a943f1a45ab7e137b03f9dd56234324eaeb6d3424b18faf51bd670cb3a80a35940a1bc030365506c67ac3e74ec964b7102a2fe08d0d2e55f998086452d7e16acf24a861c4027b9f9a98a597e51ac8e8f94ec4b7574f43628e04acb96aa0a24b0ce8ad88e229d8a55cb56e4ce640c85df711b479a6d2fc24420df6e38a3ddecc0ba2025c6406e24ea15f9ca4859da860a45686cac2ab4736434c1687f0d3b55fc6bea271f4aa18f09acdb8cad3f0ea443", 16).unwrap();
                let expected = Int::parse_bytes(b"48d90df7e3315ea7da74586dc28a2852f964f3618dd146418cf4951146b3e895858c377fa2d7252ff3706f6ece025f0cb86f769616a7b2f1d4c2a88c34d82bd8e33eb2b9f39cf94f01e689e7e6a698c857f8caea42c7e44f1ce5f0655ac5b9fded5768c568247b81d2cda5680c98d4d4940390a7cd6b8ec485a2c9af07f1bc479f7ee8f3644411d80783ca97e11684bb4ffcdc441aa90e361a5670a66c8c53708fc77fd889fb9b9bfb82dcfd1ebf978efd922da28c3e63bcc89b464a0d493fbd035f0f22eef29000", 16).unwrap();
                let res = sigma(value);
                assert_eq!(res, expected);
            }
        }
    }
}
